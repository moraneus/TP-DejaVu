

/* Generic Monitoring Code common for all properties. */

import net.sf.javabdd.{BDD, BDDFactory}
import java.io._

import org.apache.commons.csv.{CSVFormat, CSVRecord}

import scala.collection.mutable.ListBuffer
import scala.collection.JavaConverters._
import scala.util.matching.Regex

object Options {
  var DEBUG: Boolean = false
  var PROFILE: Boolean = false
  var PRINT: Boolean = false
  var BITS: Int = 20
  var PRINT_LINENUMBER_EACH: Int = 1000
  var UNIT_TEST: Boolean = false
  var STATISTICS: Boolean = true

  // ### Prediction Extension ###
  var PREDICTION: Boolean = false
  var PREDICTION_K: Int = 0
  var PREDICTION_TYPE: String = "smart"
  var PREDICTION_RUNNING_STATE: Boolean = false
  var EXPECTED_VERDICT: Int = -1
  var FOUND_VERDICT: Boolean = false
  var RESULT_FILE: String = ""
}

object Util {
  type Binding = Map[String, Any]
  val emptyBinding: Binding = Map()

  var resultFile: PrintWriter = null
  var profileFile: BufferedWriter = null

  def openResultFile(name: String): Unit = {
    resultFile = new PrintWriter(new File(name))
  }

  def writelnResult(x: Any) = {
    resultFile.write(x + "\n")
  }

  def closeResultFile(): Unit = {
    resultFile.close()
  }

  def openProfileFile(name: String): Unit = {
    val file = new File(name)
    profileFile = new BufferedWriter(new FileWriter(file))
  }

  def writeProfile(x: Any): Unit = {
    profileFile.write(x.toString)
  }

  def writelnProfile(x: Any): Unit = {
    profileFile.write(x + "\n")
  }

  def writelnProfile(): Unit = {
    profileFile.write("\n")
  }

  def closeProfileFile(): Unit = {
    profileFile.close()
  }

  def debug(str: => String): Unit = {
    if (Options.DEBUG) println(str)
  }

  def bddToString(bdd: BDD): String = {
    if (bdd.isZero)
      "False"
    else if (bdd.isOne)
      "True"
    else
      bdd.toString
  }

  implicit def liftBDD(bdd: BDD) = new {
    def dot(msg: String = "DEBUGGING"): Unit = {
      if (Options.DEBUG) {
        println("@@@@@@@@@@@@@@@@@@@@@")
        println(msg)
        if (bdd.isZero)
          println("False")
        else if (bdd.isOne)
          println("True")
        else
          bdd.printDot()
      }
    }
  }
}

import Util._

/**
  * Patterns for checking whether the state contains a certain event.
  */

trait Pattern

case class V(name: String) extends Pattern {
  override def toString: String = name
}

case class C(value: Any) extends Pattern {
  override def toString: String = value.toString
}

/**
  * A state in a trace. A trace holds one event. Event patterns can be checked against
  * the state using the <code>holds</code> method.
  */

class State {
  type Event = (String, List[Any])

  var current: Event = null

  /**
    * Updates the current state with a new event.
    *
    * @param name the name of the event.
    * @param args the arguments of the event.
    */

  def update(name: String, args: List[Any]): Unit = {
    current = (name, args)
    // println(s"$name(${args.mkString(",")})")
  }

  /**
    * Matches an event pattern as it occurs in a formula against the current event.
    *
    * @param name     the name of the event.
    * @param patterns the argument patterns.
    * @return optional BDD in case there is a match. The BDD will represent the binding of
    *         variables to values.
    */

  def holds(name: String, patterns: List[Pattern]): Option[Binding] = {
    val (cname, cargs) = current
    var binding: Binding = emptyBinding
    if (cname != name) None else {
      assert(patterns.size == cargs.size,
        s"patterns '${patterns.mkString(",")}' do not match args: '${cargs.mkString(",")}'")
      for ((pat, value) <- patterns.zip(cargs)) {
        pat match {
          case C(v) =>
            if (v != value) return None
          case V(x) =>
            if (binding.isDefinedAt(x)) {
              if (binding(x) != value) return None
            } else {
              binding += (x -> value)
            }
        }
      }
      Some(binding)
    }
  }

  override def toString: String = {
    var result = ""
    result += "#########################################################\n"
    result += s"#### ${current._1}("
    result += current._2.mkString(",") + ")\n"
    result += "#########################################################\n"
    result
  }
}

/**
  * A variable is represented by an object of this class.
  *
  * @param F        the formula that the variable is part of.
  * @param name     the name of the variable, used for error messages
  * @param offset   the offset in the total bitvector where the bits for this variable start.
  * @param nrOfBits the number of bits allocated to represent values of this variable.
  */


class Variable(F: Formula)(name: String, bounded: Boolean, offset: Int, nrOfBits: Int) {
  val G = F.bddGenerator
  var bits: Array[Int] = (for (x <- offset + nrOfBits - 1 to offset by -1) yield x).toArray
  val quantvar: BDD = G.getQuantVars(bits)
  // needed to perform quantification.
  var next: Int = -1
  var bdds: Map[Any, BDD] = Map()
  val MAX = Math.pow(2, nrOfBits)
  val allOnes: BDD = {
    var result: BDD = G.True
    for (pos <- bits) {
      result = result.and(G.theOneBDDFor(pos))
    }
    result
  }
  val freeInitially: BDD = allOnes.not
  var free: BDD = freeInitially
  var seen: BDD = G.False
  var inRelation: BDD = G.False

  /**
    * Records the fact that a BDD for this variable occurs in a relation, thus
    * preventing it from being garbage collected.
    *
    * @param bdd the BDD being recorded as being part of a relation.
    */

  def inRelation(bdd: BDD): Unit = {
    if (!bounded) inRelation = inRelation.or(bdd) // only add if not already added (i.e. the variable is bounded)
  }

  /**
    * Returns the BDD corresponding to the value, according to the enumeration of the value.
    * Either it exists already or it is built.
    *
    * @param v the value for which a BDD must be created.
    * @return the BDD corresponding to <code>v</code>.
    */

  def getBddOf(v: Any): BDD = {
    if (bdds.contains(v)) {
      val result = bdds(v)
      result.dot(s"Looking up existing BDD for $v")
      result
    } else {
      free.dot(s"free before get new BDD for variable $name for positions ${bits.mkString(",")}")
      if (timeToGarbageCollect) collectGarbage()
      if (free.isZero) {

        // ### Prediction Extension ###
        if (!Options.PREDICTION_RUNNING_STATE) writelnResult(s"${F.monitor.lineNr} oom")
        assert(false, s"Out of memory for variable $name!")
      }
      val result = free.satOne(allOnes, true)

      free = free.and(result.not())
      bdds += (v -> result)
      F.addTouchedByLastEvent(name, v, result)
      result.dot(s"BDD for $name=$v")
      if (bounded) {
        seen = seen.or(result)
        seen.dot("seen thereafter")
      }
      free.dot("free thereafter")
      result
    }
  }

  /**
    * Determines whether it is time to garbage collect for a variable.
    *
    * @return true if it is time to garbage collect.
    */

  def timeToGarbageCollect: Boolean = {
    !bounded && free.isZero
  }

  /**
    * Collects garbage for a variable.
    */

  def collectGarbage(): Unit = {
    F.monitor.garbageWasCollected = true
    debug("+++++ START GARBAGE COLLECTION +++++")
    free = freeInitially
    free.dot(s"##### free initially")
    for (i <- F.indices) {
      val bdd_i = G.getFreeBDDOf(name, F.pre(i)) // not sure we access now at the right time
      free = free.and(bdd_i)
      bdd_i.dot(s"##### bdd_i for index $i")
      free.dot(s"##### free this cycle around")
    }
    free.dot(s"++++++++++ free after garbage collection before taking uncollectable into account ++++++++++")
    inRelation.dot(s"++++++++++ uncollectable before garbage collection ++++++++++")
    free = free.and(inRelation.not())
    free.dot(s"++++++++++ free after garbage collection ++++++++++")
    removeGarbageValues()
  }

  /**
    * Called after the <code>collectGarbage()</code> has been called to remove all
    * value-BDD mappings, where the BDD has been garbage collected.
    */

  def removeGarbageValues(): Unit = {
    val values = bdds.keySet
    for (v <- values) {
      val bdd = bdds(v)
      if (bdd.imp(free).isOne) {
        debug(s"removing variable $name's entry for value $v")

        // ### Prediction Extension ###
        if (!Options.PREDICTION_RUNNING_STATE) writelnResult(s"${F.monitor.lineNr} -- $v")
        bdds -= v
      }
    }
    debug(s"Remaining entries for variable $name: ${bdds.keySet.mkString(", ")}")
  }
}

/**
  * An object of this class represents all the variables in a formula,
  * including variables containing time values if timed temporal properties
  * occur in the property.
  *
  * It contains a mapping from variable names (strings) to objects of
  * class <code>Variable</code>, each of which contains the hashmap
  * from values of the corresponding variable to BDDs.
  *
  * @param variables      the variables in the formula, each indicated by
  *                       name, whether it is bounded (true = yes), and number of bits representing it.
  * @param bitsPerTimeVar the number of bits to be allocated per time variable.
  *                       This number is `0` if the property does not contain
  *                       timed temporal operators.
  */

class BDDGenerator(F: Formula)(variables: List[(String, Boolean, Int)], bitsPerTimeVar: Int) {
  var B: BDDFactory = BDDFactory.init(10000, 10000)
  val True: BDD = B.one()
  val False: BDD = B.zero()
  var offset: Int = 0
  val totalNumberOfBits: Int = variables.map(_._3).sum
  var varMap: Map[String, Variable] = Map()
  lazy val otherQuantVars: Map[String, List[BDD]] = {
    val varNames = variables.map(_._1)
    var result: Map[String, List[BDD]] = (for (varName <- varNames) yield (varName -> Nil)).toMap
    for (varName1 <- varNames; varName2 <- varNames if varName1 != varName2) {
      val otherQuantVarsSoFar = result(varName1)
      val newOtherQuant = varMap(varName2).quantvar
      result += (varName1 -> (newOtherQuant :: otherQuantVarsSoFar))
    }
    result
  }

  val nrOfTimeVariables = 5

  // ### Prediction Extension ###
  if (totalNumberOfBits > 0 || bitsPerTimeVar > 0) {
    var predictionExtraBits = 0
    if (Options.PREDICTION) predictionExtraBits += 2 * variables.head._3
    B.setVarNum(totalNumberOfBits + predictionExtraBits + (nrOfTimeVariables * bitsPerTimeVar))
  }

  /**
    * Returns a BDD for the bit positions provided as argument. The BDD is used to
    * represent the bits to quantify over for a particular DejaVu formula variable.
    *
    * @param bits the bit positions (variables) to include in the BDD.
    * @return a BDD over those variables.
    */

  def getQuantVars(bits: Array[Int]): BDD = {
    B.buildCube(0, bits).support()
  }

  /**
    * The BDD for a single position that is true only of that bit is 1.
    *
    * @param pos the position making part of the resulting BDD.
    * @return the BDD accepting on 1 for that position.
    */

  def theOneBDDFor(pos: Int): BDD = {
    B.ithVar(pos)
  }

  // ### Prediction Extension ###
  /**
    * The BDD for a single position that is true only of that bit is 0.
    *
    * @param pos the position making part of the resulting BDD.
    * @return the BDD accepting on 0 for that position.
    */

  def theZeroBDDFor(pos: Int): BDD = {
    B.nithVar(pos)
  }

  /**
    * Initializes the <code>varMap</code> variable by mapping each variable in the formula to
    * an instance of the <code>Variable</code> class.
    */

  def initializeVariables(): Unit = {
    for ((x, b, v) <- variables) {
      varMap += (x -> new Variable(F)(x, b, offset, v))
      offset += v
    }
  }

  /**
    * Get the BDD of value <code>v</code> when assigned to variable <code>x</code>.
    *
    * @param x the variable the value <code>v</code> is assigned to.
    * @param v the value being assigned to <code>x</code>.
    * @return the BDD representing the value <code>v</code>.
    */

  def getBddOf(x: String, v: Any): BDD =
    varMap(x).getBddOf(v)

  /**
    * Collects the garbage for a variable in a sub-formula. This is done using the formula:
    *
    * <code>
    * forall y0,...,z0,... . (F[1/x0,...,1/xn] <-> F)
    * </code>
    *
    * where <code>x</code> is the variable, and <code>x0,x1,...,xn</code> are the bit positions for that variable,
    * and <code>y0,...,z0,...</code> are the bit positions for all other variables <code>y, z, ...</code>.
    * The formula defines a BDD which accepts values <code>v</code> for <code>x</code> (in <code>F</code>)
    * such that <code>F[v/x]</code> is identical to <code>F[1/x0,...,1/xn]</code>. Those are the values
    * that are no longer needed, hence can be garbage collected. Recall that 111..1 represents all values not
    * yet seen.
    *
    * @param varName the name of the variable being garbage collected (<code>x</code> in the above example).
    * @param formula the formula being garbage collected over (<code>F</code> in the above example).
    * @return the free assignments.
    */

  def getFreeBDDOf(varName: String, formula: BDD): BDD = {
    val variable = varMap(varName)
    val formulaWithOnes = formula.restrict(variable.allOnes)
    var result = formulaWithOnes.biimp(formula)
    for (quantVar <- otherQuantVars(varName)) result = result.forAll(quantVar)
    result
  }
}

/**
  * Maintains trace statistics for a monitoring session. It specifically keeps track of
  * which events occur in the trace, how many times, and how this relates to the events
  * referred to in the specification. Can be useful for debugging a specification.
  *
  * @param events the events referred to in the specification
  */

class TraceStatistics(events: Set[String]) {
  var eventTable: Map[String, Long] = events.map(_ -> 0.asInstanceOf[Long]).toMap

  def update(eventName: String): Unit = {
    eventTable.get(eventName) match {
      case None => eventTable += (eventName -> 1)
      case Some(count) => eventTable += (eventName -> (count + 1))
    }
  }

  override def toString: String = {
    var result: String = ""
    result += "==================\n"
    result += "  Event Counts:\n"
    result += "------------------\n"
    val maxNameSize = eventTable.keySet.map(_.size).max
    for ((name, count) <- eventTable) {
      val spaces = maxNameSize - name.size
      val namePadded = name + (" " * spaces)
      result += f"  $namePadded : $count"
      if (count == 0) {
        result += " event did not occur in trace\n"
      } else if (!(events contains name)) {
        result += " unknown\n"
      } else {
        result += "\n"
      }
    }
    result += "==================\n"
    result
  }
}

/**
  * The generic Monitor class.
  * A specialized monitor for a set of properties must extend this class.
  * It contains the BDD generator (which generates the association between values
  * and BDDs), the state (which contains the current event), and the list of user
  * provided formulas. In addition it provides a set of options that can be set
  * by the user.
  */

abstract class Monitor {
  val state: State = new State
  var formulae: List[Formula] = Nil
  var lineNr: Int = 0
  var garbageWasCollected: Boolean = false
  var statistics: TraceStatistics = new TraceStatistics(eventsInSpec)
  var currentTime: Int = 0
  var deltaTime: Int = 0
  var errors: Int = 0

  /**
    * Sets the current time to the time indicated by the timestamp associated
    * with the latest event. It specifically sets `deltaTime` to denote the
    * difference between the previous time stamp and this one.
    *
    * @param timeStamp the new time value for the latest event.
    */

  def setTime(timeStamp: Int): Unit = {
    deltaTime = timeStamp - currentTime
    currentTime = timeStamp
  }

  /**
    * Returns the set of events referred to in the specification, either defined, or referred to
    * in the LTL formulas. Must be overridden by generated specification specific monitor.
    *
    * @return the set of referred to events.
    */

  def eventsInSpec: Set[String]

    /**
      * Returns the mapping of variables referred to each event in the specification.
      * Must be overridden by generated specification specific monitor.
      *
      * @return mapping of variables referred to each event.
      */

    def eventsInVars: Map[String, List[String]]

   /**
     * Returns the mapping of constants referred to each value in the specification.
     * Must be overridden by generated specification specific monitor.
     *
     * @return mapping of constants referred to each value.
     */

    def eventsInConstants: Map[String, List[String]]

  /**
    * Returns the mapping of multiple values predicates referred to each value in the specification.
    * Must be overridden by generated specification specific monitor.
    *
    * @return mapping of multiple values predicates referred to each value.
    */

    def multipleValuesPredicates: Map[Array[String], List[String]]

  /**
    * Used for timing performance. The timing is printed on standard output.
    *
    * @param block the code block that is being timed.
    * @tparam R the result type of the block.
    * @return the result of the block.
    */

  def time[R](block: => R): R = {
    val t1 = System.currentTimeMillis()
    val result = block
    val t2 = System.currentTimeMillis()
    val ms = (t2 - t1).toFloat
    val sec = ms / 1000
    println()
    println("Elapsed analysis time: " + sec + "s")
    result
  }

  /**
    * Submits an event to the monitor. This again causes the monitor evaluation to be
    * performed, which will evaluate all asserted formulas on this new event.
    *
    * @param name the name of the event.
    * @param args the arguments to the event.
    */

  def submit(name: String, args: List[Any]): Unit = {
    if (Options.STATISTICS) {
      statistics.update(name)
    }
    state.update(name, args)
    evaluate()
  }

  /**
    * Vararg (variable length argument list) variant of method above. This form allows calls
    * like <code>submit("send",1,2)</code> rather than writing <code>submit("send",List(1,2))</code>.
    * Submits an event to the monitor. This again causes the monitor evaluation to be
    * performed, which will evaluate all asserted formulas on this new event.
    *
    * @param name the name of the event.
    * @param args the arguments to the event.
    */

  def submit(name: String, args: Any*): Unit = {
    submit(name, args.toList)
  }

  /**
    * Submits an entire trace to the monitor, as an alternative to submitting
    * events one by one. This method can only be called in offline monitoring.
    *
    * @param events the trace.
    */

  def submitTrace(events: List[(String, List[Any])]): Unit = {
    for ((event, args) <- events) {
      submit(event, args)
    }
    // end()
  }

  /**
    * Submits an entire trace stored in CSV (Comma Separated Value format) format
    * to the monitor, as an alternative to submitting events one by one. This method
    * can only be called in offline monitoring.
    *
    * @param file the log file in CSV format to be verified.
    */

  def submitCSVFile(file: String) {
    val in: Reader = new BufferedReader(new FileReader(file))
    // DEFAULT.withHeader()
    val timed: Boolean = file.contains(".timed.")
    var eventSize: Int = 0
    time {
      val records: Iterable[CSVRecord] = CSVFormat.DEFAULT.parse(in).asScala
      lineNr = 0

      for (record <- records) {
        lineNr += 1
        if (Options.PRINT && lineNr % Options.PRINT_LINENUMBER_EACH == 0) {
          if (lineNr >= 1000000)
            println(lineNr.toDouble / 1000000 + " M")
          else if (lineNr >= 1000)
            println(lineNr.toDouble / 1000 + " K")
          else
            println(lineNr.toDouble)
        }
        val name = record.get(0)
        var args = new ListBuffer[Any]()
        if (timed) {
          eventSize = record.size() - 1
          val timeStamp: Int = record.get(eventSize).toInt
          setTime(timeStamp)
        } else {
          eventSize = record.size()
        }
        for (i <- 1 until eventSize) {
          args += record.get(i)
        }
        submit(name, args.toList)
      }
      println(s"Processed $lineNr events")
      in.close()
      // end()
    }
  }

  /**
    * Called at the end of a trace analysis. Only called in connection of
    * log analysis (analysis of finite traces).
    */

  def end(): Unit = {
    println(s"\n$errors errors detected!\n")
    if (Options.STATISTICS) println(statistics)
    if (garbageWasCollected) {
      println("*** GARBAGE COLLECTOR WAS ACTIVATED!")
    } else {
      println("- Garbage collector was not activated")
    }
  }

  /**
    * Evaluates all formulas on a new state (new event). In case a property is violated an
    * error message is printed. There is currently no other consequence of a violated
    * property.
    */

  def evaluate(): Unit = {
    debug(s"\ncurrentTime = $currentTime\n$state\n")
    for (formula <- formulae) {
      formula.setTime(deltaTime)
      if (!formula.evaluate()) {
        errors += 1
        // println(s"\n*** Property ${formula.name} violated on event number $lineNr:\n")
        // println(state)
      }
    }
  }

  /**
    * Records property violation in the result file. Currently only event number
    * of violating event is recorded. This information is used for unit testing.
    */

  def recordResult(): Unit = {
    // ### Prediction Extension ###
    if (!Options.PREDICTION_RUNNING_STATE) writelnResult(lineNr)
  }

  /**
    * Prints information useful for understanding the data written to the profile CSV file.
    */

  def printProfileHeader(): Unit = {
    formulae(0).printProfileHeader()
  }
}

/**
  * Every formula will be defined as a class extending this class.
  *
  */

abstract class Formula(val monitor: Monitor) {
  // A property named xyz will be defined by a class Formula_xyz. Pick out the name xyz:
  var name: String = this.getClass.getSimpleName.split("_")(1)
  // BDD generator:
  var bddGenerator: BDDGenerator = null
  // Pre and now arrays, as in article:
  var pre: Array[BDD] = null
  var now: Array[BDD] = null
  // temporary pointer, used to swap the pre and now arrays:
  var tmp: Array[BDD] = null
  // maps sub-formula indexes to the text format of the sub-formulas, used for
  // debugging purposes:
  var txt: Array[String] = null
  // indices of temporal formulas, used for computing free assignments during garbage collection:
  val indices: List[Int]
  // stores variable-value-bdd pairs of newly detected values for most recent event, null means no relations:
  val emptyTouchedSet: Set[(String, Any, BDD)] = Set()
  var touchedByLastEvent: Set[(String, Any, BDD)] = emptyTouchedSet
  // records variables referred to in relations. Used to pre-condition update of above variable:
  var varsInRelations: Set[String] = Set()

  /**
    * Type of relational operators.
    */

  trait RelOp {
    def compare(v1: Any, v2: Any): Boolean
  }

  /**
    * The '<' relational operator.
    */

  case object LTOP extends RelOp {
    def compare(v1: Any, v2: Any): Boolean = {
      v1.asInstanceOf[String].toInt < v2.asInstanceOf[String].toInt
    }

    override def toString = "<"
  }

  /**
    * The '<=' relational operator.
    */

  case object LEOP extends RelOp {
    def compare(v1: Any, v2: Any): Boolean = {
      v1.asInstanceOf[String].toInt <= v2.asInstanceOf[String].toInt
    }

    override def toString = "<="
  }

  /**
    * The '>' relational operator.
    */

  case object GTOP extends RelOp {
    def compare(v1: Any, v2: Any): Boolean = {
      v1.asInstanceOf[String].toInt > v2.asInstanceOf[String].toInt
    }

    override def toString = ">"
  }

  /**
    * The '>=' relational operator.
    */

  case object GEOP extends RelOp {
    def compare(v1: Any, v2: Any): Boolean = {
      v1.asInstanceOf[String].toInt >= v2.asInstanceOf[String].toInt
    }

    override def toString = ">="
  }

  /**
    * The '=' relational operator.
    */

  case object EQOP extends RelOp {
    def compare(v1: Any, v2: Any): Boolean = {
      v1 == v2
    }

    override def toString = "="
  }

  /**
    * Turns an optional binding from variable names to values (an assignment) into a BDD.
    * This is achieved by computing the BDD for each variable/value pair and the  AND-ing these BDDs
    * together. The function is called when an event pattern has matched an incoming
    * event in the state.
    *
    * @param binding the binding to convert into a BDD.
    * @return the BDD resulting from and-ing the BDDs for each variable binding in <code>binding</code>.
    */

  def bddFromBinding(binding: Option[Binding]): BDD = {
    binding match {
      case None => bddGenerator.False
      case Some(b) =>
        var bdd: BDD = bddGenerator.True
        for ((x, v) <- b) {
          bdd = bdd.and(bddGenerator.getBddOf(x, v))
        }
        bdd
    }
  }

  /**
    * Builds a BDD from an event pattern, matching it against the latest
    * incoming event in the current state. A particular event pattern either matches the
    * current event or not. If so, values are bound to formal parameter names of the event,
    * forming a binding (assignment). The BDD is then created from this binding.
    *
    * @param name     the name of the event.
    * @param patterns the patterns that are meant to match the arguments of the actual event.
    * @return the BDD resulting from the match, False if no match occurred.
    */

  def build(name: String)(patterns: Pattern*): BDD =
    bddFromBinding(monitor.state.holds(name, patterns.toList))

  /**
    * Builds a BDD from a relational expression of the form: <code>varName1 op varName2</code>, only
    * comparing the new values seen in this event.
    *
    * @param varName1 the name of the left-hand side variable.
    * @param op       the operator.
    * @param varName2 the name of the right-hand side variable.
    * @return the BDD resulting from comparing new values against previous values.
    */

  def relation(varName1: String, op: RelOp, varName2: String): BDD = {
    val variable1 = bddGenerator.varMap(varName1)
    val variable2 = bddGenerator.varMap(varName2)
    var result: BDD = bddGenerator.False
    for ((varName, value, bdd) <- touchedByLastEvent) {
      if (varName == varName1) {
        for ((value2, bdd2) <- variable2.bdds) {
          if (op.compare(value, value2)) {
            result = result.or(bdd.and(bdd2))
            variable1.inRelation(bdd)
            variable2.inRelation(bdd2)
            debug(s"adding [$varName1:$value] $op $varName2:$value2 to '$varName1 $op $varName2'  BDD")
          }
        }
      }
      if (varName == varName2) {
        for ((value1, bdd1) <- variable1.bdds) {
          if (op.compare(value1, value)) {
            result = result.or(bdd.and(bdd1))
            variable1.inRelation(bdd1)
            variable2.inRelation(bdd)
            debug(s"adding $varName1:$value1 $op [$varName2:$value] to '$varName1 $op $varName2'  BDD")
          }
        }
      }
    }
    result
  }

  /**
    * Builds a BDD from a relational expression of the form: <code>varName op const</code>, only
    * comparing the new values seen in this event.
    *
    * @param varName the name of the left-hand side variable.
    * @param op      the operator.
    * @param const   the right-hand side constant.
    * @return the BDD resulting from comparing new value against the constant.
    */

  def relationToConstant(varName: String, op: RelOp, const: Any): BDD = {
    val variable = bddGenerator.varMap(varName)
    var result: BDD = bddGenerator.False
    for ((`varName`, value, bdd) <- touchedByLastEvent if op.compare(value, const)) {
      result = result.or(bdd)
      variable.inRelation(bdd)
      debug(s"adding [$varName:$value] $op $const to '$varName $op $const'  BDD")
    }
    result
  }

  /**
    * If the formula contains relations (<code>touchedByLastEvent != null</code>), this function
    * adds a newly generated binding of a variable to a value and binding. This is used for updating
    * the relational expressions.
    *
    * @param name  the name of the variable.
    * @param value the value it is bound to.
    * @param bdd   the corresponding BDD generated.
    */

  def addTouchedByLastEvent(name: String, value: Any, bdd: BDD): Unit = {
    if (varsInRelations.contains(name)) {
      touchedByLastEvent += ((name, value, bdd))

      // ### Prediction Extension ###
      debug(s"recording binding $name -> $value (assignment: ${bdd.satOne()}) for subsequent relation updating")
    }
  }

  /**
    * Adds a time value `d` to a time value `t`, resulting in the new time value `u` using
    * carrier bits `c` as auxiliary variables.
    *
    * Time values are represented by BDDs. Each such BDD, call it  `B`, represents a sequence of
    * bits `B1,...,Bn` mentioned from least significant bit to most significant bit. This
    * allows a recursive algorithm, which adds bits from lowest to highest significant bit.
    * The `c` the carrier bits used to carry over.
    *
    * E.g. say we want to add `t=01`` (the number 1) and `d=01` (the number 1). These are
    * passed to this function as `10` and `10` respectively (least significant bits first).
    * The function adds `1` and `1` giving `0` and resulting in carrier bit `c1` being `1`.
    * `c1=1` is then used when adding the two `0` resulting in `1`, overall resulting in `01`
    * with the least significant but mentioned first, hence this is
    * `10` in normal bit format (the number 2).
    *
    * The function takes care of the first (least significant) bit addition, and then calls
    * `addConstRest` for the rest of the bits.
    *
    * @param t the time value to add to (from previous event).
    * @param u the resulting time value.
    * @param d the time delta to add to `t` (the time difference between this and previous event).
    * @param c the carrier bits used as auxiliary variable.
    * @return the BDD defining the result `u` of the addition.
    **/

  def addConst(t: List[BDD], u: List[BDD], d: List[BDD], c: List[BDD]): BDD = {
    (t, u, d, c) match {
      case (t_bit :: t_rest, u_bit :: u_rest, d_bit :: d_rest, c_bit :: c_rest) =>
        val initBDD = u_bit.biimp(t_bit.xor(d_bit))
        val initCarrier = c_bit.biimp(t_bit.and(d_bit))
        initBDD.and(initCarrier).and(addConstRest(t_rest, u_rest, d_rest, c_bit :: c_rest))
      case _ => assert(false, "addConst pattern match fails").asInstanceOf[BDD]
    }
  }

  /**
    * Adds a time value `d` to a time value `t`, resulting in the new time value `u` using
    * carrier bits `c` as auxiliary variables.
    *
    * This function is called on all bits following the least significant bit. See
    * `addConst`.
    *
    * @param t the time value to add to (from previous event).
    * @param u the resulting time value.
    * @param d the time delta to add to `t` (the time difference between this and previous event).
    * @param c the carrier bits used as auxiliary variable.
    * @return the BDD defining the result `u` of the addition.
    */

  def addConstRest(t: List[BDD], u: List[BDD], d: List[BDD], c: List[BDD]): BDD = {
    (t, u, d, c) match {
      case (Nil, Nil, Nil, _) => bddGenerator.True
      case (t_bit :: t_rest, u_bit :: u_rest, d_bit :: d_rest, c_prev :: c_cur :: c_rest) =>
        val u_bit_def = u_bit.biimp(t_bit.xor(d_bit).xor(c_prev))
        val c_cur_def = c_cur.biimp(
          (t_bit.and(d_bit)).or(
            t_bit.and(c_prev).or(
              d_bit.and(c_prev)
            )
          ))
        u_bit_def.and(c_cur_def.and(addConstRest(t_rest, u_rest, d_rest, c_cur :: c_rest)))
      case _ => assert(false, "addConstRest pattern match fails").asInstanceOf[BDD]
    }
  }

  /**
    * Returns true of the first `bit1` is one and the second `bit2` is zero.
    *
    * @param bit1 the first bit.
    * @param bit2 the second bit.
    * @return the `True` BDD if the first bit is one and the second is zero.
    */

  def gtBit(bit1: BDD, bit2: BDD): BDD =
    bit1.and(bit2.not())

  /**
    * Determines whether one time value `u` is strictly bigger than another `l`.
    * The time values are presented with the most significant bit first, and the
    * function recurses over the bits comparing them until the result becomes
    * obvious.
    *
    * E.g. to compare binary `101` (number 5) to binary `110` (number 6) the
    * function first compares the first two `1`s, which does not determine the
    * result. It then moves on to the next two bits `0` and `1`, and here it becomes
    * clear that the first number is not bigger than the second.
    *
    * @param u the first time value (the time difference of the current event)
    * @param l the second time value (the limit constant associated with the S-operator)
    * @return the result of the comparison, `True` if the first number is bigger than the second.
    *         Otherwise `False`.
    */

  def gtConst(u: List[BDD], l: List[BDD]): BDD = {
    (u, l) match {
      case (Nil, Nil) => bddGenerator.False
      case (u_bit :: u_rest, l_bit :: l_rest) =>
        gtBit(u_bit, l_bit).ite(
          bddGenerator.True,
          gtBit(l_bit, u_bit).ite(
            bddGenerator.False,
            gtConst(u_rest, l_rest)
          )
        )
      case _ => assert(false, "gtConst pattern match fails").asInstanceOf[BDD]
    }
  }

  /**
    * From a list of BDD variable-numbers (the JavaBDD package represents a
    * variable by a number), the function returns a list of the BDDs, one for
    * each of these variables. The BDD returns `1` for `1` and `0` for `0`.
    *
    * @param positions the numbers of the variables.
    * @return the corresponding one-bit BDDs.
    */

  def generateBDDList(positions: Array[Int]): List[BDD] = {
    for (pos <- positions.toList) yield bddGenerator.theOneBDDFor(pos)
  }

  /**
    * Sets the time delta in the individual formula. Note that the delta stored in the
    * individual formula is a function of the maximal time limit occurring in
    * the formula, in order to save bits. It is meant to be overridden by each
    * formula class if the formula contains time constraints.
    *
    * @param actualDelta the actual difference in time between the timestamp of
    *                    the previous event and the current event.
    */

  def setTime(actualDelta: Int) {}

  /**
    * Returns the True BDD if the Delta time (the time difference between the
    * time stamp of the current event and the time stamp of the previous event)
    * is less than the time limit passed as argument, otherwise the False BDD
    * is returned.
    *
    * @param timeLimit the timelimit (small delta) occuring as part of a temporal
    *                  operator in the property being evaluated.
    * @return the True or False BDD, depending on whether the time passed since last
    *         event is less than the argument time value or not.
    */

  def deltaLessThanTimeLimit(timeLimit: Int): BDD = {
    if (monitor.deltaTime < timeLimit)
      bddGenerator.True
    else
      bddGenerator.False
  }

  /**
    * Declares all variables (each identified by a name) in a formula.
    * This includes initializing the BDD generator, which is stored in
    * <code>bddGenerator</code>, and initializing <code>True</code> and
    * <code>False</code>. The result returned is a list of the Variable objects.
    * In addition BDD variables are allocated for keeping track of time in case
    * the property contains timed temporal operators. In this case `bitsPerTimeVar > 0`.
    *
    * @param variables      the (name,bounded) pairs for variables in a formula.
    * @param bitsPerTimeVar the number of bits to be allocated per time variable.
    *                       This number is `0` if the property does not contain
    *                       timed temporal operators.
    * @return a list of Variable objects, one for each variable.
    */

  def declareVariables(variables: (String, Boolean)*)(bitsPerTimeVar: Int): List[Variable] = {
    val variableList = variables.toList
    val nameList: List[String] = variableList.map(_._1)
    val varsAndBitsPerVar = variableList.map {
      case (n, b) => (n, b, Options.BITS)
    }
    bddGenerator = new BDDGenerator(this)(varsAndBitsPerVar, bitsPerTimeVar)
    bddGenerator.initializeVariables()
    nameList.map(bddGenerator.varMap(_))
  }

  /**
    * The evaluation method for a formula. Must be overridden for each formula.
    * The method will evaluate the formula on each new event.
    *
    * @return true iff. the formula is true on the trace seen so far.
    */

  def evaluate(): Boolean

  /**
    * Returns a string representation of the current values of the <code>pre</code> and
    * <code>now</code> arrays. For each index into these arrays also the text of the
    * subformula is printed for better comprehension.
    *
    * @return string representation of formula state.
    */

  override def toString: String = {
    var result: String = ""
    result += s"===============\n"
    result += s"Property $name:\n"
    result += s"===============\n"
    for (i <- 0 to now.size - 1) {
      result += s"[$i] ${txt(i)}\n\n"
      result += s"pre: ${bddToString(pre(i))}\n"
      result += s"now: ${bddToString(now(i))}\n"
      result += s"-------------\n"
    }
    result
  }

  /**
    * Prints information useful for understanding what is written to the profile CSV file.
    */

  def printProfileHeader(): Unit = {
    println()
    println("================")
    println(s"Property: $name")
    println("================")
    println()
    println("Profile data written to CSV file dejavu-profile.csv")
    println()
    println("Formulas:")
    println()
    // --- profiling: ---
    // val profiledIndices = indices ++ List(4) // access property
    // val profiledIndices = List(25) // fifo property
    // val profiledIndices = List(7) // locking property
    // val profiledIndices = List(13,16) // deadlock property
    // val profiledIndices = List(4,20) // datarace property
    val profiledIndices = indices
    // ------------------
    for (i <- profiledIndices) {
      println(s"----- $i -----")
      println(txt(i))
      writeProfile(s"nodeCount$i,pathCount$i,satCount$i,compr$i,")
    }
    writelnProfile()
  }

  /**
    * Prints a formula state for debugging. This includes whether the formula is true or not,
    * and the value of the <code>now</code> array, where each entry is printed both as a one
    * line text value, and also as a graph in dot format for visualization with GraphViz.
    *
    * In profile mode, profiling data are written to a CSV file.
    */

  def debugMonitorState(): Unit = {
    if (Options.PROFILE) { // Designed to profile one formula.
      val line = new StringBuffer()
      // --- profiling: ---
      // val profiledIndices = indices ++ List(4) // access property
      // val profiledIndices = List(25) // fifo property
      // val profiledIndices = List(7) // locking property
      // val profiledIndices = List(13,16) // deadlock property
      // val profiledIndices = List(4,20) // datarace property
      val profiledIndices = indices
      // ------------------
      for (i <- profiledIndices) {
        val bdd: BDD = now(i)
        val nodeCount: Int = bdd.nodeCount()
        val pathCount: Double = bdd.pathCount()
        val satCount: Double = bdd.satCount()
        val compression: Double = if (nodeCount != 0) satCount / nodeCount else 0
        // val varProfile: Array[Int] = bdd.varProfile()

        line.append(s"$nodeCount,$pathCount,$satCount,$compression,")
      }
      writelnProfile(line)
    }
    if (Options.DEBUG) {
      println("================")
      println(s"Property: $name")
      println("================")
      println()
      if (now(0).isZero) {
        println("*** FALSE ***")
        println()
      }
      for (i <- now.size - 1 to 0 by -1) {
        println(s"----- $i -----")
        println(txt(i))
        if (now(i).isOne) println("TRUE") else if (now(i).isZero) println("FALSE") else {
          println(s"now:")
          println(now(i)) // prints BDD as a one line text
          now(i).printDot() // prints BDD in dot format for vizualization with GraphViz
        }
      }
    }
  }
}



/*
  prop P1 : !(Exists A . Exists B . Exists d . P (end(B) & @ P (begin(B,d) & @ P (end(A) & @ P begin(A,d)))))
*/

class Formula_P1(monitor: Monitor) extends Formula(monitor) {

  override def evaluate(): Boolean = {
    // assignments1 (leaf nodes that are not rule calls):
      now(6) = build("end")(V("B"))
      now(10) = build("begin")(V("B"),V("d"))
      now(14) = build("end")(V("A"))
      now(17) = build("begin")(V("A"),V("d"))
    // assignments2 (rule nodes excluding what is below @ and excluding leaf nodes):
    // assignments3 (rule calls):
    // assignments4 (the rest of rules that are below @ and excluding leaf nodes):
    // assignments5 (main formula excluding leaf nodes):
      now(16) = now(17).or(pre(16))
      now(15) = pre(16)
      now(13) = now(14).and(now(15))
      now(12) = now(13).or(pre(12))
      now(11) = pre(12)
      now(9) = now(10).and(now(11))
      now(8) = now(9).or(pre(8))
      now(7) = pre(8)
      now(5) = now(6).and(now(7))
      now(4) = now(5).or(pre(4))
      now(3) = now(4).exist(var_d.quantvar)
      now(2) = now(3).exist(var_B.quantvar)
      now(1) = now(2).exist(var_A.quantvar)
      now(0) = now(1).not()

    debugMonitorState()

    val error = now(0).isZero
    if (error) monitor.recordResult()
    tmp = now
    now = pre
    pre = tmp
    touchedByLastEvent = emptyTouchedSet
    !error
  }

  val var_A :: var_B :: var_d :: Nil = declareVariables(("A",false), ("B",false), ("d",false))(0)

  varsInRelations = Set()
  val indices: List[Int] = List(4,7,8,11,12,15,16)

  pre = Array.fill(18)(bddGenerator.False)
  now = Array.fill(18)(bddGenerator.False)

  txt = Array(
    "!(Exists A . Exists B . Exists d . P (end(B) & @ P (begin(B,d) & @ P (end(A) & @ P begin(A,d)))))",
      "Exists A . Exists B . Exists d . P (end(B) & @ P (begin(B,d) & @ P (end(A) & @ P begin(A,d))))",
      "Exists B . Exists d . P (end(B) & @ P (begin(B,d) & @ P (end(A) & @ P begin(A,d))))",
      "Exists d . P (end(B) & @ P (begin(B,d) & @ P (end(A) & @ P begin(A,d))))",
      "P (end(B) & @ P (begin(B,d) & @ P (end(A) & @ P begin(A,d))))",
      "end(B) & @ P (begin(B,d) & @ P (end(A) & @ P begin(A,d)))",
      "end(B)",
      "@ P (begin(B,d) & @ P (end(A) & @ P begin(A,d)))",
      "P (begin(B,d) & @ P (end(A) & @ P begin(A,d)))",
      "begin(B,d) & @ P (end(A) & @ P begin(A,d))",
      "begin(B,d)",
      "@ P (end(A) & @ P begin(A,d))",
      "P (end(A) & @ P begin(A,d))",
      "end(A) & @ P begin(A,d)",
      "end(A)",
      "@ P begin(A,d)",
      "P begin(A,d)",
      "begin(A,d)"
  )

  debugMonitorState()
}

/* The specialized Monitor for the provided properties. */

class PropertyMonitor extends Monitor {
  def eventsInSpec: Set[String] = Set("end","begin")

  // ### Prediction Extension ###
  val eventsInVars: Map[String, List[String]] = Map( "B" -> List("end"),"A" -> List("end") )
  val eventsInConstants: Map[String, List[String]] = Map( )
  val multipleValuesPredicates: Map[Array[String], List[String]] = Map( Array( "B","d" ) -> List("begin"),Array( "A","d" ) -> List("begin") )

  formulae ++= List(new Formula_P1(this))
}


// ### Prediction Extension ###

// Define a simple mutable wrapper for a boolean value
class MutableBoolean(var value: Boolean)

abstract class Prediction(monitor: Monitor) {
  val G: BDDGenerator = monitor.formulae.head.bddGenerator
  val formula: Formula = monitor.formulae.head
  val vars: Map[String, Variable] = G.varMap
  Options.PREDICTION_RUNNING_STATE = true
  var counter = 0
  val wrappedPattern: Regex = { "''([^*]+)''".r }

  /**
    *
    * The main prediction function, which is works by recursion.
    *
    * @param k             the k step for the prediction
    * @param predictedEvents the predicts event seen so far
    */

  def prediction(k: Int, predictedEvents: ListBuffer[(String, String, Int)]): Unit

  /**
    * Store the current state of the monitoring process.
    * This is necessary before taking any recursion step in the prediction process.
    *
    * @param M               the monitor object
    * @param V               a variable object which is the one we wants to store his dynamically states.
    * @param nowTmp          a tmp array which save the F.now BDDs array.
    * @param preTmp          a tmp array which save the F.pre BDDs array.
    * @param statTmp         a tmp array which save the M.error and M.lineNr values.
    * @param variableBddsTmp a tmp array which save the V.free, V.seen, V.inRelation BDDs.
    */

  def storePreviousState(
                          M: Monitor,
                          V: Array[Variable],
                          nowTmp: Array[BDD],
                          preTmp: Array[BDD],
                          statTmp: Array[Int],
                          variableBddsTmp: Array[BDD]): Unit = {

    nowTmp.indices.foreach(i => nowTmp(i) = formula.now(i))
    preTmp.indices.foreach(i => preTmp(i) = formula.pre(i))

    statTmp(0) = M.lineNr
    statTmp(1) = M.errors
    M.lineNr += 1

    var base = 0
    for (index <- V.indices) {
      variableBddsTmp(base + 0) = V(index).free
      variableBddsTmp(base + 1) = V(index).seen
      variableBddsTmp(base + 2) = V(index).inRelation
      base += 3
    }
  }

  /**
    * Restore the previous state of the monitoring process.
    * This is necessary right after any recursion step is done in the prediction process.
    *
    * @param M               the monitor object
    * @param V               a variable object which is the one we wants to store his dynamically states.
    * @param nowTmp          a tmp array which hold the previous F.now BDDs array.
    * @param preTmp          a tmp array which hold the previous the F.pre BDDs array.
    * @param statTmp         a tmp array which hold the previous the M.error and M.lineNr values.
    * @param variableBddsTmp a tmp array which hold the previous the V.free, V.seen, V.inRelation BDDs.
    */

  def restorePreviousState(
                            M: Monitor,
                            V: Array[Variable],
                            nowTmp: Array[BDD],
                            preTmp: Array[BDD],
                            statTmp: Array[Int],
                            variableBddsTmp: Array[BDD]): Unit = {

    nowTmp.indices.foreach(i => formula.now(i) = nowTmp(i))
    preTmp.indices.foreach(i => formula.pre(i) = preTmp(i))

    M.lineNr = statTmp(0)
    M.errors = statTmp(1)

    var base = 0
    for (index <- V.indices) {
      V(index).free = variableBddsTmp(base + 0)
      V(index).seen = variableBddsTmp(base + 1)
      V(index).inRelation = variableBddsTmp(base + 2)
      base += 3
    }
  }

  def printPredictionSummary(predictedEvents: ListBuffer[(String, String, Int)]): Unit = {
    // Prints the selected path
    println("\n\n######### SUMMARY OF PREDICTION #########\n")

    var predictionAsString = ""
    for (event <- predictedEvents) {
      val currEventState = s"${event._1}(${event._2})=${event._3}"
      predictionAsString += currEventState + ";"
      print(s"$currEventState -> ")
    }
    println("DONE")
    writelnResult(s"${predictionAsString.dropRight(1)}")

    // Print the summary of trace (including extension)
    println(s"Processed ${monitor.lineNr} events")
  }

  def handleBaseCase(predictedEvents: ListBuffer[(String, String, Int)]): Unit = {
    if (predictedEvents.last._3 == Options.EXPECTED_VERDICT) {
      Options.FOUND_VERDICT = true
    }
    counter += 1
    // printPredictionSummary(predictedEvents)
    // monitor.end()
  }


 /**
   * Initializes the necessary variables for the prediction function.
   *
   * @param predictedEvents  The ListBuffer of predicted events as tuples (String, String, Int).
   * @return                 A tuple containing the following values:
   *                           - tmpPredictedEvents: ListBuffer[(String, String, Int)]
   *                           - tmpEventTable: Map[String, Long]
   *                           - tmpVarBdds: Array[Map[Any, BDD]]
   *                           - tmpStat: Array[Int]
   *                           - tmpVariableBdds: Array[BDD]
   *                           - tmpPre: Array[BDD]
   *                           - tmpNow: Array[BDD]
   *                           - singleConstValuedPredicateFlag: Boolean
   *                           - multipleConstValuedPredicatesFlag: Boolean
   *                           - multipleValuesPredicatesFlag: Map[Array[String], MutableBoolean]
   */
   def initializeVariables(predictedEvents: ListBuffer[(String, String, Int)]):
   (
     ListBuffer[(String, String, Int)],
     Map[String, Long],
     Array[Map[Any, BDD]],
     Array[Int],
     Array[BDD],
     Array[BDD],
     Array[BDD],
     Boolean,
     Boolean,
     Map[Array[String], MutableBoolean]) = {

      // Defines all the tmp objects in order to have the ability to restore previous
      // states while going back and forth in recursion.
      val tmpEventTable: Map[String, Long] = null
      val tmpVarBdds: Array[Map[Any, BDD]] = Array.fill(3)(null)
      val tmpStat: Array[Int] = Array.fill(2)(0)
      val tmpVariableBdds = Array.fill(3 * 3)(G.False)
      val tmpPre: Array[BDD] = Array.fill(18)(G.False)
      val tmpNow: Array[BDD] = Array.fill(18)(G.False)
      val tmpPredictedEvents: ListBuffer[(String, String, Int)] = predictedEvents

      // Used to avoid duplicates when spec have constants or predicate with multiple values.
      // If true, we need to handle constants and predicate with multiple values.
      // All are initialize to true.
      val singleConstValuedPredicateFlag = true
      val multipleConstValuedPredicatesFlag = true
      val multipleValuesPredicatesFlag = monitor.multipleValuesPredicates.map { case (key, _) => (key, new MutableBoolean(true))}

     // The return tuple
     (tmpPredictedEvents,
      tmpEventTable,
      tmpVarBdds,
      tmpStat,
      tmpVariableBdds,
      tmpPre,
      tmpNow,
      singleConstValuedPredicateFlag,
      multipleConstValuedPredicatesFlag,
      multipleValuesPredicatesFlag)
   }
 }

// ### Prediction Extension ###
class BruteForcePrediction(monitor: Monitor) extends Prediction(monitor) {

  /**
   * The main prediction function, which is works by recursion.
   *
   * @param k             the k step for the prediction
   * @param predictedEvents the predicts event seen so far
   */
  override def prediction(k: Int, predictedEvents: ListBuffer[(String, String, Int)]): Unit = {

       // Recursion Base case
       if (k == 0) {
         handleBaseCase(predictedEvents)
         return
       }


    // Initialize necessary variables
    var
    (tmpPredictedEvents,
    tmpEventTable,
    tmpVarBdds,
    tmpStat,
    tmpVariableBdds,
    tmpPre,
    tmpNow,
    singleConstValuedPredicatesFlag,
    multipleConstValuedPredicatesFlag,
    multipleValuesPredicatesFlag) = initializeVariables(predictedEvents)



    // Loop through all property variables
    for ((varName, varObject) <- vars) {
      var equivClassesNum = 0

      // Filter relevant multiple values predicates
      var relevantMultipleValuesPredicates =
        monitor.multipleValuesPredicates.filterKeys {
          key =>
            val a = key.contains(varName)
            val b = key.forall(item => wrappedPattern.findFirstIn(item).isDefined)
            a || b && multipleConstValuedPredicatesFlag
        }

      // If false, we are now going to handle multiple values predicates,
      // so in the next iteration the handled multiple values predicates will be ignored.
      if (relevantMultipleValuesPredicates.nonEmpty) {
        for (key <- relevantMultipleValuesPredicates.keys) {
          if (multipleValuesPredicatesFlag(key).value) {
            multipleValuesPredicatesFlag(key).value = false
          } else {
            relevantMultipleValuesPredicates = relevantMultipleValuesPredicates.filterKeys(k => !(k sameElements key))
          }
        }
      }

      var varAssignments = varObject.bdds
      val unseenValue = generateValue(varAssignments)
      varAssignments += (unseenValue -> null)

      for (assignment <- varAssignments) {
        equivClassesNum += 1

        // Fetch one value of corresponds isomorphic assignment.
        val fetchedValue = assignment._1.toString

        // Filter relevant event types
        val filteredEvents = monitor.eventsInVars.filterKeys(_ == varName)
        // Include eventsInConstants if singleConstValuedPredicatesFlag is true
        val allRelevantEvents = if (singleConstValuedPredicatesFlag) filteredEvents ++ monitor.eventsInConstants else filteredEvents

        // If false, we are now going to handle constants,
        // so in the next iteration the handled constants will be ignored.
        singleConstValuedPredicatesFlag = false

        // Process Events
        if (allRelevantEvents.nonEmpty) {
          processRelevantEvents()
        }
        if (relevantMultipleValuesPredicates.nonEmpty) {
          processMultipleValuesPredicates()
        }
        debug(s"##### Total Equivalence classes for variable=$varName and for k=$k is $equivClassesNum #####")

        // Function to process an event
        def processEvent(eventList: List[String], currentValues: List[String], relevantVars: List[Variable]): Unit = {
          eventList.foreach { event =>
            // Store the current state before taking the recursion step
            storePreviousState(monitor, relevantVars.toArray, tmpNow, tmpPre, tmpStat, tmpVariableBdds)
            tmpEventTable = monitor.statistics.eventTable

            for (index <- relevantVars.indices) {
                tmpVarBdds(index) = relevantVars(index).bdds
             }

            // Submit the event with the current values
            monitor.submit(event, currentValues)

            // Calculate the event error and append the event to the predicted events list
            val eventError = if (tmpStat(1) < monitor.errors) 0 else 1
            tmpPredictedEvents.append((event, currentValues.mkString(","), eventError))

            // Continue prediction if a verdict hasn't been found
            if (!Options.FOUND_VERDICT) {
              prediction(k - 1, tmpPredictedEvents)
            }

            // Recover the previous state when arriving here
            tmpPredictedEvents = tmpPredictedEvents.dropRight(k)
            restorePreviousState(monitor, relevantVars.toArray, tmpNow, tmpPre, tmpStat, tmpVariableBdds)
            monitor.statistics.eventTable = tmpEventTable

            for (index <- relevantVars.indices) {
               relevantVars(index).bdds = tmpVarBdds(index)
             }

          }
        }

        // Processes relevant events for a given variable and fetched value.
        def processRelevantEvents(): Unit = {

          // Iterate through all relevant events
          allRelevantEvents.foreach { case (value, eventList) =>

            // Determine the value to be used for evaluation
            val evaluationValue: String = if (value != varName) value else fetchedValue

            // Process event
            processEvent(eventList, List(evaluationValue), List(varObject))
          }
        }

        /**
          * Processes relevant multiple values predicates for a given variable and fetched value.
          */
        def processMultipleValuesPredicates(): Unit = {
          // Iterate through all relevant multiple values predicates
          for ((values, eventList) <- relevantMultipleValuesPredicates) {
            // Call the helper function processValue with the initial index and an empty list
            processValue(0, List.empty[String], List.empty[Variable])

            // Helper function to process each value in the values array and submit the event
            def processValue(index: Int, currentValues: List[String], relevantVars: List[Variable]): Unit = {
              if (index < values.length) {
                val item = values(index)

                // Match the item and process accordingly
                item match {
                  case wrappedPattern(value) =>
                    processValue(index + 1, currentValues :+ value, relevantVars)

                  // If the item is a variable, append the fetched value and continue processing
                  case variable if variable == varName =>
                    val updatedRelevantVars: List[Variable] = relevantVars :+ varObject
                    processValue(index + 1, currentValues :+ fetchedValue, updatedRelevantVars)

                  // If the item is not the current variable, process it as another variable
                  case _ if item != varName =>
                    val relevantVar = G.varMap.filterKeys(_.contains(item))
                    if (relevantVar.nonEmpty) {
                      val varObject = relevantVar(item)
                      var varAssignments = varObject.bdds
                      val unseenValue = generateValue(varAssignments)
                      varAssignments += (unseenValue -> null)
                      val updatedRelevantVars: List[Variable] = relevantVars :+ varObject

                      for (assignment <- varAssignments) {

                        // Fetch one value
                        val anotherFetchedValue = assignment._1.toString
                        processValue(index + 1, currentValues :+ anotherFetchedValue, updatedRelevantVars)
                      }
                    }
                }
              } else {
                // Process event
                processEvent(eventList, currentValues, relevantVars)
              }
            }
          }
        }

        multipleConstValuedPredicatesFlag = false
      }
    }
  }

  /**
    * In this function we fetching a value which will use for the prediction.
    * The fetching process search for a matching value between the 'ia' BDD and the variable
    * related values. In a case where no matching was found (should happens only when '11...11'
    * appears on is own in equivalence class), we generate a new value which is not seen yet.
    *
    * @param ia a BDD which hold isomorphic values related to the
    *           current variable in the prediction process.
    * @param v  the current variable in the prediction process.
    * @return the fetched/generated value.
    */
  def generateValue(varAssignments: Map[Any, BDD]): String = {
    var tmpVal = if (varAssignments.nonEmpty) varAssignments.head._1.toString else ""
    tmpVal += "1"
    var foundNewValue = false
    while (!foundNewValue) {
      if (varAssignments.contains(tmpVal)) {
        tmpVal += "1"
      } else {
        foundNewValue = true
      }
    }
    tmpVal
    }
}


 // ### Prediction Extension ###
class SmartPrediction(monitor: Monitor) extends Prediction(monitor) {

   /***
     * The main prediction function, which is works by recursion.
     *
     * @param k               the k step for the prediction
     * @param predictedEvents   the predicts event seen so far
     */
     def prediction(k: Int, predictedEvents: ListBuffer[(String, String, Int)]): Unit = {

       // Recursion Base case
       if (k == 0) {
         handleBaseCase(predictedEvents)
         return
       }


      // Initialize necessary variables
      var
      (tmpPredictedEvents,
      tmpEventTable,
      tmpVarBdds,
      tmpStat,
      tmpVariableBdds,
      tmpPre,
      tmpNow,
      singleConstValuedPredicatesFlag,
      multipleConstValuedPredicatesFlag,
      multipleValuesPredicatesFlag) = initializeVariables(predictedEvents)

       // Loop through all property variables
       for ((varName, varObject) <- vars) {
         var (ghBdd, gQuantVars) = calculateGhBdd(varName, varObject, formula)
         var equivClassesNum = 0

         // Filter relevant multiple values predicates
         var relevantMultipleValuesPredicates =
             monitor.multipleValuesPredicates.filterKeys {
               key =>
                 val a = key.contains(varName)
                 val b = key.forall(item => wrappedPattern.findFirstIn(item).isDefined)
                 a || b && multipleConstValuedPredicatesFlag
             }

         // If false, we are now going to handle multiple values predicates,
         // so in the next iteration the handled multiple values predicates will be ignored.
         if(relevantMultipleValuesPredicates.nonEmpty) {
           for (key <- relevantMultipleValuesPredicates.keys) {
             if (multipleValuesPredicatesFlag(key).value) {
               multipleValuesPredicatesFlag(key).value = false
             } else {
               relevantMultipleValuesPredicates = relevantMultipleValuesPredicates.filterKeys(k => k != key)
             }
           }
          }

         while (!ghBdd.equals(G.False) && ghBdd != null) {
           equivClassesNum += 1

           // Represent satisfying assignment and its isomorphic assignments for a given ghBdd
           val iaBDD = findSatisfyingAssignment(ghBdd, varObject, gQuantVars)

           // Removes all isomorphic assignments of 'satAssignmentG' from 'gh' BDD
           ghBdd = ghBdd.and(iaBDD.not())

           // Fetch one value of corresponds isomorphic assignment.
           val fetchedValue = fetchingValue(iaBDD, varObject)

           // Filter relevant event types
           val filteredEvents = monitor.eventsInVars.filterKeys(_ == varName)
           // Include eventsInConstants if singleConstValuedPredicatesFlag is true
           val allRelevantEvents = if (singleConstValuedPredicatesFlag) filteredEvents ++ monitor.eventsInConstants else filteredEvents

           // If false, we are now going to handle constants,
           // so in the next iteration the handled constants will be ignored.
           singleConstValuedPredicatesFlag = false

           // Process Events
           if(allRelevantEvents.nonEmpty) { processRelevantEvents() }
           if(relevantMultipleValuesPredicates.nonEmpty) { processMultipleValuesPredicates() }
           debug(s"##### Total Equivalence classes for variable=$varName and for k=$k is $equivClassesNum #####")


           // Function to process an event
           def processEvent(eventList: List[String], currentValues: List[String], relevantVars: List[Variable]): Unit = {
             eventList.foreach { event =>
               // Store the current state before taking the recursion step
               storePreviousState(monitor, relevantVars.toArray, tmpNow, tmpPre, tmpStat, tmpVariableBdds)
               tmpEventTable = monitor.statistics.eventTable

               for (index <- relevantVars.indices) {
                  tmpVarBdds(index) = relevantVars(index).bdds
               }

               // Submit the event with the current values
               monitor.submit(event, currentValues)

               // Calculate the event error and append the event to the predicted events list
               val eventError = if (tmpStat(1) < monitor.errors) 0 else 1
               tmpPredictedEvents.append((event, currentValues.mkString(","), eventError))

               // Continue prediction if a verdict hasn't been found
               if (!Options.FOUND_VERDICT) {
                 prediction(k - 1, tmpPredictedEvents)
               }

               // Recover the previous state when arriving here
               tmpPredictedEvents = tmpPredictedEvents.dropRight(k)
               restorePreviousState(monitor, relevantVars.toArray, tmpNow, tmpPre, tmpStat, tmpVariableBdds)
               monitor.statistics.eventTable = tmpEventTable


               for (index <- relevantVars.indices) {
                 relevantVars(index).bdds = tmpVarBdds(index)
               }
             }
           }

           // Processes relevant events for a given variable and fetched value.
           def processRelevantEvents(): Unit = {

             // Iterate through all relevant events
             allRelevantEvents.foreach { case (value, eventList) =>

                // Determine the value to be used for evaluation
                 val evaluationValue: String = if (value != varName) value else fetchedValue

                 // Process event
                 processEvent(eventList, List(evaluationValue), List(varObject))
             }
           }

           /**
             * Processes relevant multiple values predicates for a given variable and fetched value.
             */
           def processMultipleValuesPredicates(): Unit = {
             // Iterate through all relevant multiple values predicates
             for ((values, eventList) <- relevantMultipleValuesPredicates) {
                 // Call the helper function processValue with the initial index and an empty list
                 processValue(0, List.empty[String], List.empty[Variable])

                 // Helper function to process each value in the values array and submit the event
                 def processValue(index: Int, currentValues: List[String], relevantVars: List[Variable]): Unit = {
                   if (index < values.length) {
                     val item = values(index)

                     // Match the item and process accordingly
                     item match {
                       case wrappedPattern(value) =>
                         processValue(index + 1, currentValues :+ value, relevantVars)

                       // If the item is a variable, append the fetched value and continue processing
                       case variable if variable == varName =>
                         val updatedRelevantVars: List[Variable] = relevantVars :+ varObject
                         processValue(index + 1, currentValues :+ fetchedValue, updatedRelevantVars)

                       // If the item is not the current variable, process it as another variable
                       case _ if item != varName =>
                         val relevantVar = G.varMap.filterKeys(_.contains(item))
                         if (relevantVar.nonEmpty) {
                           val varObject = relevantVar.getOrElse(item, null)
                           val updatedRelevantVars: List[Variable] = relevantVars :+ varObject
                           var (ghBdd, gQuantVars) = calculateGhBdd(item, varObject, formula)
                           while (!ghBdd.equals(G.False) && ghBdd != null && varObject != null) {
                             val iaBDD = findSatisfyingAssignment(ghBdd, varObject, gQuantVars)
                             // Removes all isomorphic assignments of 'satAssignmentG' from 'gh' BDD
                             ghBdd = ghBdd.and(iaBDD.not())

                             // Fetch one value of corresponds isomorphic assignment
                             val anotherFetchedValue = fetchingValue(iaBDD, varObject)
                             processValue(index + 1, currentValues :+ anotherFetchedValue, updatedRelevantVars)
                           }
                         }
                     }
                   } else {
                     // Process event
                     processEvent(eventList, currentValues, relevantVars)
                   }
                 }
             }
           }
           multipleConstValuedPredicatesFlag = false
         }
       }
     }

   /**
    * Calculates the ghBdd and gQuantVars values for a given variable and formula.
    *
    * @param varName    The name of the variable.
    * @param varObject  The Variable object associated with the variable name.
    * @return           A tuple containing the calculated ghBdd (BDD) and gQuantVars (Array[BDDVarSet]).
    */
   def calculateGhBdd(varName: String, varObject: Variable, F: Formula): (BDD, BDD) = {
     var ghBdd = G.True
     val varBits = varObject.bits
     val varBitsLength = varBits.length

     val gArrayBits = Array.range(G.totalNumberOfBits, G.totalNumberOfBits + varBitsLength)
     val gQuantVars = G.getQuantVars(gArrayBits)

     // Loop through all tmp relations, represent as BDDs
     // The tmp array holds the latest relations.
     for (i <- formula.tmp.indices) {
       val otherQuantVars = G.otherQuantVars(varName)

       // If the target BDD is true or false, this has no influence on the result.
       if (!formula.tmp(i).isZero && !formula.tmp(i).isOne) {
         val isoBdd = IsomorphicPairsCalculator(varObject, otherQuantVars, formula.tmp(i), gArrayBits)
         ghBdd = ghBdd.and(isoBdd)
       }
     }

     (ghBdd, gQuantVars)
   }

   /**
    * Finds a satisfying assignment and its isomorphic assignments for a given ghBdd, varObject, and gQuantVars.
    *
    * @param ghBdd      The BDD object representing the GH relation.
    * @param varObject  The Variable object associated with the variable name.
    * @param gQuantVars The Array of BDDVarSet representing the quantifier variables.
    * @return           A tuple containing the satisfying assignment (satAssignmentG: BDD) and its isomorphic assignments (iaBDD: BDD).
    */
   def findSatisfyingAssignment(ghBdd: BDD, varObject: Variable, gQuantVars: BDD): BDD = {
     // Get one satisfying assignment
     val satAssignmentG = ghBdd.satOne(gQuantVars, true).exist(varObject.quantvar)

     // Gets all isomorphic assignments of 'satAssignmentG'
     // 'ia' for isomorphic assignments
     val iaBDD = ghBdd.restrict(satAssignmentG)

     iaBDD
   }

  /**
   * In this function we fetching a value which will use for the prediction.
   * The fetching process search for a matching value between the 'ia' BDD and the variable
   * related values. In a case where no matching was found (should happens only when '11...11'
   * appears on is own in equivalence class), we generate a new value which is not seen yet.
   *
   * @param ia  a BDD which hold isomorphic values related to the
   *            current variable in the prediction process.
   * @param v   the current variable in the prediction process.
   * @return    the fetched/generated value.
   */

   def fetchingValue(ia: BDD, v: Variable): String = {
     val varAssignments = v.bdds
     val varAssignmentsInList = new ListBuffer[String]()
     for (assignment <- varAssignments) {
       val assignmentValue = assignment._1.toString
       varAssignmentsInList += assignmentValue
       if (!assignment._2.and(ia).equals(G.False)) return assignmentValue
     }

     // If no matching is found, return the max value (alphanumeric order) + 1
     if (varAssignmentsInList.isEmpty) "1" else (varAssignmentsInList.max + 1)
   }

  /**
    * Find all isomorphic variable assignments in a given BDD.
    * The returned result is a BDD GH over a bit vector 'g1 . . . gn' and 'h1 . . . hn' such
    * that the bit vectors 'g1 . . . gn' and 'h1 . . . hn' represent pairs of values 'g' and 'h', where
    * 'g' and 'h' are isomorphic over relation R (represented by the input BDD 'bdd').
    *
    * @param variable       The variable object, which is the target to calculate isomorphic pairs over 'bdd'.
    * @param otherQuantVars The other quant vars.
    * @param bdd            The target BDD, which the isomorphic pairs will be searched in it.
    * @param gArrayBits     The bits indexes for the bit vector 'g1 . . . gn' (which starts from the last defined variable bits).
    * @return               BDD GH over a bit vector 'g1 . . . gn' and 'h1 . . . hn'.
    */

   def IsomorphicPairsCalculator(variable: Variable, otherQuantVars: List[BDD], bdd: BDD, gArrayBits: Array[Int]): BDD = {

     // Extract the target variable corresponding bits
     val varBits = variable.bits

     // Define pairs of bits.
     // Used for future bits order changing
     val pairsG = G.B.makePair
     val pairsH = G.B.makePair

     val hStartBit = varBits.head + 1
     val hArrayBits = Array.range(hStartBit,
       hStartBit + varBits.length)

     pairsG.set(varBits.reverse, gArrayBits)
     pairsH.set(gArrayBits, hArrayBits)


     var ghBdd = bdd.replace(pairsG).biimp(bdd)
     for (quantVar <- otherQuantVars) ghBdd = ghBdd.forAll(quantVar)
     ghBdd.replaceWith(pairsH)
  }
}


 // ### Prediction Extension ###
object TraceMonitor {
  private val usage: String =
 """Usage: (--logfile <filename>) [--bits numOfBits] [--mode (debug | profile)]
    |         [--prediction num] [--prediction_type (smart | brute)] [--expected_verdict (0 | 1)]
 """.stripMargin

  def main(args: Array[String]): Unit = {

    if (2 <= args.length && args.length <= 14 && args.length % 2 == 0) {
      val argMapBuilder = Map.newBuilder[String, Any]
      args.sliding(2, 2).toList.collect {
        case Array("--logfile", logfile: String) => argMapBuilder.+=("logfile" -> logfile)
        case Array("--bits", numOfBits: String) => argMapBuilder.+=("bits" -> numOfBits)
        case Array("--mode", mode: String) => argMapBuilder.+=("mode" -> mode)
        case Array("--prediction", predictionLength: String) => argMapBuilder.+=("prediction" -> predictionLength)
        case Array("--prediction_type", predictionType: String) => argMapBuilder.+=("prediction_type" -> predictionType)
        case Array("--expected_verdict", expectedVerdict: String) => argMapBuilder.+=("expected_verdict" -> expectedVerdict)
        case Array("--resultfile", resultfile: String) => argMapBuilder.+=("resultfile" -> resultfile)
      }

      val argMap = argMapBuilder.result()

      val logFile = argMap.get("logfile")
      val logfilePath = logFile match {
        case Some(value) => value.toString
        case None =>
          println(s"*** program must be called with logfile argument")
          println(usage)
          return
      }

      var dir = new File(logfilePath)
      if (!dir.exists) {
        println(s" ***logfile is not a valid file")
        return
      }

      val resultfile = argMap.get("resultfile")
      Options.RESULT_FILE = resultfile match {
        case Some(value) => value.toString
        case None => "/Users/moraneus/Documents/Studies/phd/Runtime-Verification-Prediction-Paper/dejavu-prediction/dejavu-with-prediction/src/test/scala/experiments/prediction_experiments/./output/dejavu-results"
      }

      dir = new File(Options.RESULT_FILE)
      if (!dir.getParentFile.exists) {
        println(s" ***resultfile parent is not a valid folder")
        return
      }

      val bits = argMap.get("bits")
      val bitsValue = bits match {
        case Some(value) =>
          if (!value.toString.matches("""\d+""")) {
            println(s"*** bits argument must be an integer")
            return
          } else {
            value.toString
          }
        case None => "20" // Default is 20 bits length
      }
      Options.BITS = bitsValue.toInt

      val prediction = argMap.get("prediction")
      val predictionValue = prediction match {
        case Some(value) =>
          if (!value.toString.matches("""\d+""")) {
            println(s"*** prediction argument must be an integer")
            return
          } else {
            Options.PREDICTION = true
            value.toString
        }
        case None => "0"
      }
      Options.PREDICTION_K = predictionValue.toInt

      val predictionType = argMap.get("prediction_type")
      predictionType match {
        case Some(value) =>
          val predictionTypeValue = value.toString.toLowerCase()
          if (predictionTypeValue == "brute") Options.PREDICTION_TYPE = "brute"
          else if (predictionTypeValue == "smart") Options.PREDICTION_TYPE = "smart"
          else {
            println(s"*** prediction type argument must be: smart or brute")
            return
          }
        case None => println("No prediction type was selected (default is smart)")
      }

      val expectedType = argMap.get("expected_verdict")
      expectedType match {
        case Some(value) =>
          val expectedTypeValue = value.toString
          if (expectedTypeValue == "0") Options.EXPECTED_VERDICT = 0
          else if (expectedTypeValue == "1") Options.EXPECTED_VERDICT = 1
          else {
            println(s"*** expected verdict argument must be: 1 or 0")
            return
          }
        case None => println("No expected verdict type was selected (default is None)")
      }

      val mode = argMap.get("mode")
      mode match {
        case Some(value) =>
          val modeValue = value.toString.toLowerCase()
          if (modeValue == "debug") Options.DEBUG = true
          else if (modeValue == "profile") Options.PROFILE = true
          else {
            println(s"*** mode argument must be: debug or profile")
            return
          }
        case None => println("No mode was selected")
      }

      val m = new PropertyMonitor

      try {
        openResultFile(Options.RESULT_FILE)
        if (Options.PROFILE) {
          openProfileFile("dejavu-profile.csv")
          m.printProfileHeader()
        }
        m.submitCSVFile(logfilePath)


       if (Options.PREDICTION) {
          if (m.multipleValuesPredicates.isEmpty && m.eventsInVars.isEmpty) {
            println(s"*** Prediction is not available for this spec without any predicate with values")
          } else {
          time {
            var prediction: Prediction = null
            if (Options.PREDICTION_TYPE == "brute") {
              prediction = new BruteForcePrediction(m)
            } else {
              prediction = new SmartPrediction(m)
            }
            val events = new ListBuffer[(String, String, Int)]()
            prediction.prediction(Options.PREDICTION_K, events)
            println(s"### Total Predictions: ${prediction.counter}")
            }
          }
        } else {
          println("Prediction was not activated")
        }
     } catch {
        case e: Throwable =>
          println(s"\n*** $e\n")
        // e.printStackTrace()
      } finally {
        closeResultFile()
        if (Options.PROFILE) closeProfileFile()
      }
    } else {
      println("*** call with these arguments:")
      println(usage)
    }
  }
}
      
